import copy

from alg.semi_supervised import SemiSupervised
from lib.ops import evaluate
from lib.utils import load_avast_weeks_pca, parse_arguments

args = parse_arguments()

dataset_avast_pca = {
    'name': 'avast_pca',
    'input_size': 128,
    'num_classes': 5,
    'mlp_arch': [96, 64, 32],
    'visualise_funcs': ['losses']
}

dataset_avast_pca_binary = copy.deepcopy(dataset_avast_pca)
dataset_avast_pca_binary['num_classes'] = 2

ds = dataset_avast_pca_binary if args.binary else dataset_avast_pca

if args.m:  # can't load matplotlib in metacentrum
    ds['visualise_funcs'] = []


def train(run_nmb, x, y, x_un=None, y_un=None, x_test=None, y_test=None):
    semi_sup = SemiSupervised(
        dataset_params=ds,
        num_epoch=100,
        ssl_method=args.method,
        options=args.options,
        hyper_par=args.hyper_par,
        save_results=False,
        imbalanced=False,
        should_evaluate=True
    )

    semi_sup.set_train_data(x, y)
    if x_test is not None and y_test is not None:
        semi_sup.set_test_data(x_test, y_test)

    if x_un is not None:
        semi_sup.set_unsupervised_data(x_un)
    else:
        semi_sup.split_sup_unsup(args.ratio)

    semi_sup.prepare_train_test_data()

    model = semi_sup.train(run_nmb)
    return model


def train_eval(run_nmb):
    x, y, x_test, y_test = load_avast_weeks_pca(args.train_weeks, 10000 + 5000, 5000, args.binary)
    print('y_test: ', y_test[:10])
    model = train(run_nmb, x, y, x_test=x_test, y_test=y_test)
    test_acc = evaluate(model, ds['num_classes'], x_test, y_test, hot=False)
    return test_acc


def main():
    with open(args.out_path + 'results.out', 'w') as f:
        print('weeks:', args.train_weeks, file=f)
        print('ratio:', args.ratio, file=f)
        print('ssl:', args.method, file=f)
        print(args.hyper_par, file=f)
        print(args.options, file=f)

    runs = args.runs
    accuracies = []
    for i in range(runs):
        acc = train_eval(i)
        print('Final test acc:', acc)
        with open(args.out_path + 'results.out', 'a') as f:
            print(i, acc, file=f)
        accuracies.append(acc)

    with open(args.out_path + 'results.out', 'a') as f:
        print('min', min(accuracies), file=f)
        print('max', max(accuracies), file=f)
        print('avg', sum(accuracies) / runs, file=f)


if __name__ == '__main__':
    main()
